<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SitSmart Demo (Client‑side MediaPipe)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      #wrap { display: grid; grid-template-columns: 360px 1fr; gap: 24px; align-items: start; }
      #stage { position: relative; width: 640px; max-width: 100%; }
      video { width: 100%; height: auto; background: #111; border-radius: 8px; display: block; transform: scaleX(-1); }
      canvas { width: 100%; height: auto; background: transparent; border-radius: 8px; display: block; }
      #overlay { position: absolute; inset: 0; pointer-events: none; background: transparent; transform: scaleX(-1); transform-origin: center; }
      .panel { padding: 16px; border: 1px solid #ddd; border-radius: 8px; }
      .controls { display: flex; gap: 8px; align-items: center; margin-top: 12px; }
      button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: #f8fafc; cursor: pointer; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      .status { font-weight: 600; }
      .good { color: #15803d; }
      .bad { color: #b91c1c; }
      .unknown { color: #6b7280; }

      /* Toast notifications */
      #toasts { position: fixed; top: 16px; right: 16px; width: min(340px, 92vw); display: flex; flex-direction: column; gap: 10px; z-index: 1000; }
      .toast { border: 1px solid #e5e7eb; border-left: 6px solid #3b82f6; background: #ffffff; border-radius: 8px; padding: 12px 12px 12px 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      .toast h4 { margin: 0 0 4px 0; font-size: 14px; }
      .toast p { margin: 0; font-size: 13px; color: #334155; }
      .toast .meta { font-size: 12px; color: #64748b; margin-top: 6px; }
      .toast button.toast-close { align-self: start; border: none; background: transparent; color: #64748b; cursor: pointer; padding: 0 4px; font-size: 16px; }
      .toast.warning { border-left-color: #f59e0b; }
      .toast.critical { border-left-color: #ef4444; }
      .toast.info { border-left-color: #3b82f6; }
    </style>
  </head>
  <body>
    <h1>SitSmart Real-time Posture Demo (Client-side)</h1>
    <div id="wrap">
      <div class="panel">
        <div id="stage">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="controls">
          <button id="startBtn">Start</button>
          <button id="stopBtn" disabled>Stop</button>
          <label>FPS <input id="fps" type="number" min="1" max="120" value="30" style="width:60px"></label>
          <span>State: <span id="state" class="status unknown">idle</span></span>
        </div>
      </div>
      <div class="panel">
        <div>Frames: <span id="frames">0</span></div>
        <div>Model: <span id="model">loading…</span></div>
        <hr />
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;flex-wrap:wrap;">
          <h3 style="margin:0;">Server Features</h3>
          <label style="font-weight:normal;font-size:12px;">Send every <input id="featureEvery" type="number" min="1" max="30" value="1" style="width:50px"> frames</label>
          <label style="font-weight:normal;font-size:12px;display:flex;align-items:center;gap:6px;">
            <input id="notifyEnabled" type="checkbox"> Enable notifications
          </label>
          <label style="font-weight:normal;font-size:12px;">Cooldown s <input id="cooldownSec" type="number" min="0" max="3600" value="5" style="width:60px"></label>
          <label style="font-weight:normal;font-size:12px;">ML threshold <input id="mlThreshold" type="number" min="0" max="1" step="0.01" value="0.60" style="width:70px"></label>
          <button id="saveConfigBtn">Save</button>
        </div>
        <div id="features" style="font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; white-space: pre-wrap; background:#f9fafb; border:1px dashed #e5e7eb; padding:8px; border-radius:6px; min-height:80px;">
          
        </div>
        <hr />
        
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
          <h3 style="margin:0;">Notifications</h3>
          <div style="font-size:12px;">Last notified: <span id="lastNotified">never</span></div>
        </div>
      </div>
    </div>

    <!-- Toast container -->
    <div id="toasts"></div>

    <script type="module">
      import { PoseLandmarker, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

      const video = document.getElementById('video');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const stateEl = document.getElementById('state');
      const framesEl = document.getElementById('frames');
      const fpsInput = document.getElementById('fps');
      const modelEl = document.getElementById('model');
      const featuresEl = document.getElementById('features');
      const featureEveryInput = document.getElementById('featureEvery');
      const toasts = document.getElementById('toasts');
      const lastNotifiedEl = document.getElementById('lastNotified');
      const notifyEnabledInput = document.getElementById('notifyEnabled');
      const cooldownSecInput = document.getElementById('cooldownSec');
      const mlThresholdInput = document.getElementById('mlThreshold');
      const saveConfigBtn = document.getElementById('saveConfigBtn');

      let landmarker = null;
      let stream = null;
      let rafId = null;
      let frames = 0;
      let lastFeaturePayloadMs = 0;
      let notifyEnabled = false;
      let lastNotificationTs = 0;

      function setState(s){ stateEl.textContent = s; stateEl.className = 'status ' + (s || 'unknown'); }

      async function loadModel(){
        const filesetResolver = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
        );
        landmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task'
          },
          runningMode: 'VIDEO',
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        modelEl.textContent = 'Pose Landmarker Lite';
      }

      function sizeCanvases(){
        const w = video.videoWidth || 640;
        const h = video.videoHeight || 480;
        overlay.width = w; overlay.height = h;
        overlay.style.width = '100%';
      }

      async function start(){
        try {
          setState('requesting-camera');
          stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
          video.srcObject = stream;
          await video.play();
          await loadModel();
          sizeCanvases();
          // Clear server-side aggregation buffer on session start
          try { await fetch('/api/features/aggregate/clear', { method: 'POST' }); } catch {}
          startBtn.disabled = true; stopBtn.disabled = false; setState('running');
          loop();
        } catch (e) {
          setState('error');
          alert('Camera/model error: ' + e);
        }
      }

      function stop(){
        if (rafId) cancelAnimationFrame(rafId); rafId = null;
        if (stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
        startBtn.disabled = false; stopBtn.disabled = true; setState('stopped');
        const ctx = overlay.getContext('2d'); ctx && ctx.clearRect(0,0,overlay.width, overlay.height);
        if (rlTimer) { clearInterval(rlTimer); rlTimer = null; }
      }

      function frameToBlob(canvas){
        return new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob); else reject(new Error('toBlob failed'));
          }, 'image/jpeg', 0.85);
        });
      }

      async function sendFeaturesSnapshot(){
        try {
          // Draw current video frame into a temp canvas with the real pixel size
          const w = video.videoWidth || 640; const h = video.videoHeight || 480;
          const temp = document.createElement('canvas'); temp.width = w; temp.height = h;
          const tctx = temp.getContext('2d');
          // Mirror horizontally to match the displayed video
          tctx.save(); tctx.scale(-1, 1); tctx.drawImage(video, -w, 0, w, h); tctx.restore();
          const blob = await frameToBlob(temp);
          const form = new FormData(); form.append('image', blob, 'frame.jpg');
          const resp = await fetch('/api/features', { method: 'POST', body: form });
          console.log('[front] POST /api/features sent');
          let data = null;
          try { data = await resp.json(); } catch (e) { console.warn('[front] /api/features JSON parse failed', e); }
          if (!resp.ok) {
            const msg = data && data.detail ? data.detail : ('HTTP ' + resp.status);
            console.error('[front] /api/features error', msg);
            throw new Error(msg);
          }
          console.log('[front] /api/features ok');
          const fv = data.features;
          if (!fv){
            console.warn('[front] /api/features no features in response', data);
            featuresEl.textContent = JSON.stringify(data, null, 2);
            return;
          }
          const pretty = [
            `shoulder_line_angle_deg: ${fv.shoulder_line_angle_deg.toFixed(2)}`,
            `head_tilt_deg: ${fv.head_tilt_deg === null ? 'null' : fv.head_tilt_deg.toFixed(2)}`,
            `head_to_shoulder_distance_px: ${fv.head_to_shoulder_distance_px.toFixed(1)}`,
            `head_to_shoulder_distance_ratio: ${fv.head_to_shoulder_distance_ratio.toFixed(3)}`,
            `shoulder_width_px: ${fv.shoulder_width_px.toFixed(1)}`
          ].join('\n');
          featuresEl.textContent = pretty;

          // If notifications are enabled, add to buffer and trigger a decision
          if (notifyEnabled) {
            try {
              await fetch('/api/features/aggregate/add', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(fv)
              });
            } catch {}
            try {
              await fetch('/api/decide/from_buffer', { method: 'POST' });
            } catch {}
          }
        } catch (e) {
          console.error('[front] sendFeaturesSnapshot failed', e);
          featuresEl.textContent = String(e);
        }
      }

      async function loadNotificationConfig(){
        try {
          const resp = await fetch('/api/notifications/config');
          const data = await resp.json();
          if (!resp.ok) return;
          const cd = Number(data.cooldown_seconds ?? 5);
          const th = Number(data.ml_bad_prob_threshold ?? 0.6);
          cooldownSecInput.value = String(cd);
          mlThresholdInput.value = th.toFixed(2);
        } catch {}
      }

      async function saveNotificationConfig(){
        const payload = {};
        const cd = Math.max(0, Math.min(3600, parseInt(cooldownSecInput.value || '0', 10)));
        const th = Math.max(0, Math.min(1, parseFloat(mlThresholdInput.value || '0.6')));
        if (!Number.isNaN(cd)) payload.cooldown_seconds = cd;
        if (!Number.isNaN(th)) payload.ml_bad_prob_threshold = th;
        try {
          await fetch('/api/notifications/config', { method: 'POST', headers: { 'Content-Type': 'application/json' }, body: JSON.stringify(payload) });
        } catch {}
      }

      function updateLastNotified(){
        if (!lastNotificationTs) { lastNotifiedEl.textContent = 'never'; return; }
        const since = Math.max(0, (Date.now() - lastNotificationTs) / 1000);
        lastNotifiedEl.textContent = since.toFixed(1) + 's ago';
      }

      function loop(){
        const ctx = overlay.getContext('2d');
        const draw = new DrawingUtils(ctx);
        const fps = Math.max(1, Math.min(30, parseInt(fpsInput.value || '15', 10)));
        const interval = 1000 / fps;
        let last = 0;

        const step = (ts) => {
          if (!landmarker || !video.srcObject) return;
          if (ts - last >= interval){
            last = ts;
            const now = performance.now();
            const result = landmarker.detectForVideo(video, now);
            ctx.clearRect(0,0,overlay.width, overlay.height);
            if (result && result.landmarks && result.landmarks[0]){
              const lms = result.landmarks[0];
              draw.drawLandmarks(lms, { color: '#10b981', lineWidth: 2, radius: 2.5 });
              draw.drawConnectors(lms, PoseLandmarker.POSE_CONNECTIONS, { color: '#3b82f6', lineWidth: 2 });
            }
            frames += 1; framesEl.textContent = String(frames);
            const every = Math.max(1, Math.min(30, parseInt(featureEveryInput.value || '5', 10)));
            if (frames % every === 0){
              // fire and forget, do not block render loop
              sendFeaturesSnapshot();
            }
          }
          rafId = requestAnimationFrame(step);
        };
        rafId = requestAnimationFrame(step);
      }

      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', stop);
      notifyEnabledInput.addEventListener('change', () => { notifyEnabled = !!notifyEnabledInput.checked; });
      saveConfigBtn.addEventListener('click', saveNotificationConfig);
      // initialize defaults
      notifyEnabled = !!notifyEnabledInput.checked;
      loadNotificationConfig();
      setInterval(updateLastNotified, 1000);

      // Notification helpers
      function showToast(notification){
        const { title, message, severity = 'info', suggested_action, ttl_seconds } = notification || {};
        const toast = document.createElement('div');
        toast.className = 'toast ' + String(severity);
        const close = document.createElement('button');
        close.className = 'toast-close';
        close.setAttribute('aria-label', 'Close');
        close.textContent = '×';
        close.addEventListener('click', () => {
          if (toast.parentNode) toast.parentNode.removeChild(toast);
        });
        const content = document.createElement('div');
        const h4 = document.createElement('h4'); h4.textContent = title || 'Notification';
        const p = document.createElement('p'); p.textContent = message || '';
        content.appendChild(h4); content.appendChild(p);
        if (suggested_action){
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = suggested_action;
          content.appendChild(meta);
        }
        toast.appendChild(content);
        toast.appendChild(close);
        toasts.appendChild(toast);
        const ttl = Math.max(3, Math.min(60, parseInt(ttl_seconds || '0', 10) || 8));
        setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, ttl * 1000);
      }

      // Webhook-based notifications: subscribe to backend broadcast via WS
      (function setupNotificationWebSocket(){
        let ws = null;
        function connect(){
          try {
            const proto = location.protocol === 'https:' ? 'wss' : 'ws';
            ws = new WebSocket(`${proto}://${location.host}/api/ws/notifications`);
            console.log('[front] WS connect', ws.url);
            ws.onmessage = (evt) => {
              try {
                const data = JSON.parse(evt.data);
                if (data && data.status === 'ready'){
                  console.log('[front] WS ready');
                  // Fetch last notification in case we missed broadcast during handshake
                  fetch('/api/notifications/last').then(r => r.json()).then(last => {
                    if (last && last.title && last.message){
                      console.log('[front] Fetch last notification', last);
                      showToast(last);
                      try { lastNotificationTs = Date.parse(last.timestamp) || Date.now(); } catch { lastNotificationTs = Date.now(); }
                      updateLastNotified();
                    }
                  }).catch(() => {});
                } else if (data && data.title && data.message){
                  console.log('[front] WS notification', data);
                  showToast(data);
                  try { lastNotificationTs = Date.parse(data.timestamp) || Date.now(); } catch { lastNotificationTs = Date.now(); }
                  updateLastNotified();
                }
              } catch {}
            };
            ws.onopen = () => { console.log('[front] WS open'); };
            ws.onerror = (e) => { console.error('[front] WS error', e); };
            ws.onclose = () => { console.warn('[front] WS closed; reconnecting'); setTimeout(connect, 1500); };
          } catch {
            // ignore
          }
        }
        connect();
      })();

      // Resize overlay when metadata is loaded
      video.addEventListener('loadedmetadata', sizeCanvases);
    </script>
  </body>
</html>
