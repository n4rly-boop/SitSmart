<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>SitSmart Demo (Client‑side MediaPipe)</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; margin: 24px; }
      #wrap { display: grid; grid-template-columns: 360px 1fr; gap: 24px; align-items: start; }
      #stage { position: relative; width: 640px; max-width: 100%; }
      video { width: 100%; height: auto; background: #111; border-radius: 8px; display: block; transform: scaleX(-1); }
      canvas { width: 100%; height: auto; background: transparent; border-radius: 8px; display: block; }
      #overlay { position: absolute; inset: 0; pointer-events: none; background: transparent; transform: scaleX(-1); transform-origin: center; }
      .panel { padding: 16px; border: 1px solid #ddd; border-radius: 8px; }
      .controls { display: flex; gap: 8px; align-items: center; margin-top: 12px; }
      button { padding: 8px 12px; border-radius: 6px; border: 1px solid #ddd; background: #f8fafc; cursor: pointer; }
      button:disabled { opacity: 0.5; cursor: not-allowed; }
      .status { font-weight: 600; }
      .good { color: #15803d; }
      .bad { color: #b91c1c; }
      .unknown { color: #6b7280; }

      /* Toast notifications */
      #toasts { position: fixed; top: 16px; right: 16px; width: min(340px, 92vw); display: flex; flex-direction: column; gap: 10px; z-index: 1000; }
      .toast { border: 1px solid #e5e7eb; border-left: 6px solid #3b82f6; background: #ffffff; border-radius: 8px; padding: 12px 12px 12px 12px; box-shadow: 0 6px 18px rgba(0,0,0,0.08); display: grid; grid-template-columns: 1fr auto; gap: 8px; }
      .toast h4 { margin: 0 0 4px 0; font-size: 14px; }
      .toast p { margin: 0; font-size: 13px; color: #334155; }
      .toast .meta { font-size: 12px; color: #64748b; margin-top: 6px; }
      .toast button.toast-close { align-self: start; border: none; background: transparent; color: #64748b; cursor: pointer; padding: 0 4px; font-size: 16px; }
      .toast.warning { border-left-color: #f59e0b; }
      .toast.critical { border-left-color: #ef4444; }
      .toast.info { border-left-color: #3b82f6; }
    </style>
  </head>
  <body>
    <h1>SitSmart Real-time Posture Demo (Client-side)</h1>
    <div id="wrap">
      <div class="panel">
        <div id="stage">
          <video id="video" autoplay playsinline muted></video>
          <canvas id="overlay"></canvas>
        </div>
        <div class="controls">
          <button id="startBtn">Start</button>
          <button id="stopBtn" disabled>Stop</button>
          <button id="reminderBtn" title="Show posture reminder">Reminder</button>
          <label>FPS <input id="fps" type="number" min="1" max="120" value="30" style="width:60px"></label>
          <span>State: <span id="state" class="status unknown">idle</span></span>
        </div>
      </div>
      <div class="panel">
        <div>Frames: <span id="frames">0</span></div>
        <div>Model: <span id="model">loading…</span></div>
        <hr />
        <div style="display:flex;justify-content:space-between;align-items:center;gap:8px;">
          <h3 style="margin:0;">Server Features</h3>
          <label style="font-weight:normal;font-size:12px;">
            Send every <input id="featureEvery" type="number" min="1" max="30" value="1" style="width:50px"> frames
          </label>
        </div>
        <div id="features" style="font-family:ui-monospace, SFMono-Regular, Menlo, monospace; font-size: 13px; white-space: pre-wrap; background:#f9fafb; border:1px dashed #e5e7eb; padding:8px; border-radius:6px; min-height:80px;">
          
        </div>
      </div>
    </div>

    <!-- Toast container -->
    <div id="toasts"></div>

    <script type="module">
      import { PoseLandmarker, FilesetResolver, DrawingUtils } from 'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest';

      const video = document.getElementById('video');
      const overlay = document.getElementById('overlay');
      const startBtn = document.getElementById('startBtn');
      const stopBtn = document.getElementById('stopBtn');
      const reminderBtn = document.getElementById('reminderBtn');
      const stateEl = document.getElementById('state');
      const framesEl = document.getElementById('frames');
      const fpsInput = document.getElementById('fps');
      const modelEl = document.getElementById('model');
      const featuresEl = document.getElementById('features');
      const featureEveryInput = document.getElementById('featureEvery');
      const toasts = document.getElementById('toasts');

      let landmarker = null;
      let stream = null;
      let rafId = null;
      let frames = 0;
      let lastFeaturePayloadMs = 0;

      function setState(s){ stateEl.textContent = s; stateEl.className = 'status ' + (s || 'unknown'); }

      async function loadModel(){
        const filesetResolver = await FilesetResolver.forVisionTasks(
          'https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@latest/wasm'
        );
        landmarker = await PoseLandmarker.createFromOptions(filesetResolver, {
          baseOptions: {
            modelAssetPath: 'https://storage.googleapis.com/mediapipe-models/pose_landmarker/pose_landmarker_lite/float16/1/pose_landmarker_lite.task'
          },
          runningMode: 'VIDEO',
          numPoses: 1,
          minPoseDetectionConfidence: 0.5,
          minPosePresenceConfidence: 0.5,
          minTrackingConfidence: 0.5
        });
        modelEl.textContent = 'Pose Landmarker Lite';
      }

      function sizeCanvases(){
        const w = video.videoWidth || 640;
        const h = video.videoHeight || 480;
        overlay.width = w; overlay.height = h;
        overlay.style.width = '100%';
      }

      async function start(){
        try {
          setState('requesting-camera');
          stream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
          video.srcObject = stream;
          await video.play();
          await loadModel();
          sizeCanvases();
          startBtn.disabled = true; stopBtn.disabled = false; setState('running');
          loop();
        } catch (e) {
          setState('error');
          alert('Camera/model error: ' + e);
        }
      }

      function stop(){
        if (rafId) cancelAnimationFrame(rafId); rafId = null;
        if (stream){ stream.getTracks().forEach(t => t.stop()); stream = null; }
        startBtn.disabled = false; stopBtn.disabled = true; setState('stopped');
        const ctx = overlay.getContext('2d'); ctx && ctx.clearRect(0,0,overlay.width, overlay.height);
      }

      function frameToBlob(canvas){
        return new Promise((resolve, reject) => {
          canvas.toBlob((blob) => {
            if (blob) resolve(blob); else reject(new Error('toBlob failed'));
          }, 'image/jpeg', 0.85);
        });
      }

      async function sendFeaturesSnapshot(){
        try {
          // Draw current video frame into a temp canvas with the real pixel size
          const w = video.videoWidth || 640; const h = video.videoHeight || 480;
          const temp = document.createElement('canvas'); temp.width = w; temp.height = h;
          const tctx = temp.getContext('2d');
          // Mirror horizontally to match the displayed video
          tctx.save(); tctx.scale(-1, 1); tctx.drawImage(video, -w, 0, w, h); tctx.restore();
          const blob = await frameToBlob(temp);
          const form = new FormData(); form.append('image', blob, 'frame.jpg');
          const resp = await fetch('/api/features', { method: 'POST', body: form });
          let data = null;
          try { data = await resp.json(); } catch (e) { /* ignore parse errors */ }
          if (!resp.ok) {
            const msg = data && data.detail ? data.detail : ('HTTP ' + resp.status);
            throw new Error(msg);
          }
          const fv = data.features;
          if (!fv){
            featuresEl.textContent = JSON.stringify(data, null, 2);
            return;
          }
          const pretty = [
            `shoulder_line_angle_deg: ${fv.shoulder_line_angle_deg.toFixed(2)}`,
            `head_tilt_deg: ${fv.head_tilt_deg === null ? 'null' : fv.head_tilt_deg.toFixed(2)}`,
            `head_to_shoulder_distance_px: ${fv.head_to_shoulder_distance_px.toFixed(1)}`,
            `head_to_shoulder_distance_ratio: ${fv.head_to_shoulder_distance_ratio.toFixed(3)}`,
            `shoulder_width_px: ${fv.shoulder_width_px.toFixed(1)}`
          ].join('\n');
          featuresEl.textContent = pretty;
        } catch (e) {
          featuresEl.textContent = String(e);
        }
      }

      function loop(){
        const ctx = overlay.getContext('2d');
        const draw = new DrawingUtils(ctx);
        const fps = Math.max(1, Math.min(30, parseInt(fpsInput.value || '15', 10)));
        const interval = 1000 / fps;
        let last = 0;

        const step = (ts) => {
          if (!landmarker || !video.srcObject) return;
          if (ts - last >= interval){
            last = ts;
            const now = performance.now();
            const result = landmarker.detectForVideo(video, now);
            ctx.clearRect(0,0,overlay.width, overlay.height);
            if (result && result.landmarks && result.landmarks[0]){
              const lms = result.landmarks[0];
              draw.drawLandmarks(lms, { color: '#10b981', lineWidth: 2, radius: 2.5 });
              draw.drawConnectors(lms, PoseLandmarker.POSE_CONNECTIONS, { color: '#3b82f6', lineWidth: 2 });
            }
            frames += 1; framesEl.textContent = String(frames);
            const every = Math.max(1, Math.min(30, parseInt(featureEveryInput.value || '5', 10)));
            if (frames % every === 0){
              // fire and forget, do not block render loop
              sendFeaturesSnapshot();
            }
          }
          rafId = requestAnimationFrame(step);
        };
        rafId = requestAnimationFrame(step);
      }

      startBtn.addEventListener('click', start);
      stopBtn.addEventListener('click', stop);

      // Notification helpers
      function showToast(notification){
        const { title, message, severity = 'info', suggested_action, ttl_seconds } = notification || {};
        const toast = document.createElement('div');
        toast.className = 'toast ' + String(severity);
        const close = document.createElement('button');
        close.className = 'toast-close';
        close.setAttribute('aria-label', 'Close');
        close.textContent = '×';
        close.addEventListener('click', () => {
          if (toast.parentNode) toast.parentNode.removeChild(toast);
        });
        const content = document.createElement('div');
        const h4 = document.createElement('h4'); h4.textContent = title || 'Notification';
        const p = document.createElement('p'); p.textContent = message || '';
        content.appendChild(h4); content.appendChild(p);
        if (suggested_action){
          const meta = document.createElement('div');
          meta.className = 'meta';
          meta.textContent = suggested_action;
          content.appendChild(meta);
        }
        toast.appendChild(content);
        toast.appendChild(close);
        toasts.appendChild(toast);
        const ttl = Math.max(3, Math.min(60, parseInt(ttl_seconds || '0', 10) || 8));
        setTimeout(() => { if (toast.parentNode) toast.parentNode.removeChild(toast); }, ttl * 1000);
      }

      async function fetchReminder(){
        try {
          const resp = await fetch('/api/reminder');
          const data = await resp.json();
          if (!resp.ok){ throw new Error(data && data.detail ? data.detail : ('HTTP ' + resp.status)); }
          showToast(data);
        } catch (e) {
          showToast({ title: 'Error', message: String(e), severity: 'critical' });
        }
      }

      reminderBtn.addEventListener('click', fetchReminder);

      // Resize overlay when metadata is loaded
      video.addEventListener('loadedmetadata', sizeCanvases);
    </script>
  </body>
</html>
